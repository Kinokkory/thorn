-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Datatype Manipulation with Template Haskell
--   
--   Thorn generates
--   
--   <ul>
--   <li>functors from various kinds of datatypes, regardless of its arity
--   or variances.</li>
--   <li>folds and unfolds from various kinds of recursive datatypes,
--   including mutually recursive ones.</li>
--   </ul>
--   
--   A single function of Thorn will give you a lot. Just try it.
@package thorn
@version 0.1.1


-- | The module Data.Thorn.Type.
module Data.Thorn.Type
data T0
data T1
data T2
data T3
data T4
data T5
data T6
data T7
data T8
data T9


-- | The module Data.Thorn.Functor.
module Data.Thorn.Functor

-- | <tt>autofmap t</tt> generates a functor function of the type
--   <tt>t</tt>.
autofmap :: TypeQ -> ExpQ

-- | <tt>autofmaptype t</tt> provides the type of <tt>$(autofmap t)</tt>.
autofmaptype :: TypeQ -> TypeQ

-- | <tt>autofmapdec s t</tt> provides a declaration of a functor function
--   for the type <tt>t</tt> with the name <tt>s</tt>, with a type
--   signature.
autofmapdec :: String -> TypeQ -> DecsQ

-- | <tt>autofunctorize t</tt> provides instance delcarations of the type
--   <tt>t</tt>, for the suitable functor classes : Funtor, Contravariant,
--   Bifunctor, or Profunctor. Multiple classes can be suitable for
--   <tt>t</tt>, when one of the variances of <tt>t</tt> is <tt>Free</tt>.
autofunctorize :: TypeQ -> DecsQ

-- | <tt>Variance</tt> is a variance of a parameter of a functor.
data Variance

-- | Covariance, one of a normal functor.
Co :: Variance

-- | Contravariance, a dual of covariance.
Contra :: Variance

-- | Free-variance, or novariance, being supposed to satisfy either
--   covariance or contravariance.
Free :: Variance

-- | Fixed-variance, or invariance, being suppoesed to satisfy both
--   covariance and contravariance.
Fixed :: Variance

-- | <tt>autovariance t</tt> provides the variances of the type <tt>t</tt>.
autovariance :: TypeQ -> ExpQ
instance Show Variance
instance Read Variance
instance Monoid Variance


-- | The module Data.Thorn.Fold.
module Data.Thorn.Fold

-- | <tt>unfixdata t</tt> provides a declaration of a nonrecursive datatype
--   whose fixpoint is the recursive type <tt>t</tt>.
unfixdata :: TypeQ -> DecsQ

-- | Special version of <tt>unfixdata</tt>. Note that
--   
--   <pre>
--   unfixdata = unfixdataEx ("Uf","") ("Uf","") ("&amp;","") ("&amp;","")
--   </pre>
unfixdataEx :: (String, String) -> (String, String) -> (String, String) -> (String, String) -> TypeQ -> DecsQ

-- | <tt>autofold u t</tt> provides a folding function for the recursive
--   type <tt>t</tt>.
autofold :: TypeQ -> TypeQ -> ExpQ

-- | <tt>autofoldtype u t</tt> provides the type of <tt>$(autofoldtype u
--   t)</tt>.
autofoldtype :: TypeQ -> TypeQ -> TypeQ

-- | <tt>autofolddec s u t</tt> provides a declaration of a folding
--   function for the recursive type <tt>t</tt> with the name <tt>s</tt>,
--   with a type signature.
autofolddec :: String -> TypeQ -> TypeQ -> DecsQ

-- | <tt>autounfold t</tt> provides an unfolding function for the recursive
--   type <tt>t</tt>.
autounfold :: TypeQ -> TypeQ -> ExpQ

-- | <tt>autounfoldtype u t</tt> provides the type of <tt>$(autounfoldtype
--   u t)</tt>.
autounfoldtype :: TypeQ -> TypeQ -> TypeQ

-- | <tt>autounfolddec s u t</tt> provides a declaration of an unfolding
--   function for the recursive type <tt>t</tt> with the name <tt>s</tt>,
--   with a type signature.
autounfolddec :: String -> TypeQ -> TypeQ -> DecsQ

-- | Mutually recursive version of <tt>unfixdata</tt>. Note that
--   
--   <pre>
--   unfixdata t = unfixdataMutual [t]
--   </pre>
unfixdataMutual :: [TypeQ] -> DecsQ

-- | Special version of <tt>unfixdataMutual</tt>. Note that
--   
--   <pre>
--   unfixdataMutual = unfixdataMutualEx ("Uf","") ("Uf","") ("&amp;","") ("&amp;","")
--   </pre>
unfixdataMutualEx :: (String, String) -> (String, String) -> (String, String) -> (String, String) -> [TypeQ] -> DecsQ

-- | <tt>autofoldMutual ts</tt> provides a folding function for the
--   mutually recursive types <tt>ts</tt>
autofoldMutual :: [(TypeQ, TypeQ)] -> Int -> ExpQ
autofoldtypeMutual :: [(TypeQ, TypeQ)] -> Int -> TypeQ
autofolddecMutual :: String -> [(TypeQ, TypeQ)] -> Int -> DecsQ

-- | <tt>autounfoldMutual ts</tt> provides an unfolding function for the
--   mutually recursive types <tt>ts</tt>.
autounfoldMutual :: [(TypeQ, TypeQ)] -> Int -> ExpQ
autounfoldtypeMutual :: [(TypeQ, TypeQ)] -> Int -> TypeQ
autounfolddecMutual :: String -> [(TypeQ, TypeQ)] -> Int -> DecsQ
autoin :: TypeQ -> TypeQ -> ExpQ
autoout :: TypeQ -> TypeQ -> ExpQ
autohylo :: TypeQ -> ExpQ

-- | Mutually recursive version of <tt>autoin</tt>.
autoinMutual :: [(TypeQ, TypeQ)] -> Int -> ExpQ

-- | Mutually recursive version of <tt>autoout</tt>.
autooutMutual :: [(TypeQ, TypeQ)] -> Int -> ExpQ

-- | Mutually recursive version of <tt>autohylo</tt>.
autohyloMutual :: [TypeQ] -> Int -> ExpQ


-- | Thorn, Datatype Manipulation with Template Haskell.
module Data.Thorn
